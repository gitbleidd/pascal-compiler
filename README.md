# Лаб №1. IO модуль
Необходимо распарсить входные данные, разбить их на лексемы и вернуть токены. 
Допустима реализация с буфером и без.
Добавить вывод ошибок.

## Описание задания
- Сделать начальную часть отчета, в которой будет проектирование IO модуля
- Запрогать спроектированные сущности (токен, вариант, сам IO с получением следующего токена)
- Проверить работоспособность потокового получения токенов

## Проектирование
Перед тем, как начать писать код я выделил несколько сущностей:
- Модуль IO
- Лексический анализатор
- Токен

### Модуль IO
Задача модуля IO считывать данные из файла и передавать их. Также данный модуль должен иметь возможность принимать сообщения об ошибках из других модулей иметь интерфейс вывода.

### Лексический анализатор (сканер)
Задача лексического анализатора формировать токены (символы) исходной программы и строить их внутреннее представление. Также ЛА должен распознавать и исключать комментарии, которые не нужны для дальнейшей трансляции.

Сканер реализован в виде отдельного класса Lexer с полями: позициии символа и текста файла.
Lexer содержит несколько методов для иногрирования лишних символов и комментариев, методы для чтения чисел, идентификаторов. И самый главный метод `GetNextToken()` для получения следующего токена.<br/>
Сканер умеет строить:
- ✅ операции (+, -, *, / и др. основные)
- ✅ константы (int, real, string)
- ✅ идентификаторы
- ✅ ключевые слова

### Токен
Так как сканер должен возвращать готовые лексемы, для был создан абстрактный класс LexicalToken. Данный класс содержит одно поле: 
- Position типа int
Хранит номер символа, с которого начинается токен.

Также были созданы 4 отдельных класса для каждого типа токена, наследующих LexicalToken.

Класс IdentifierToken предназначен для идентификаторов и содержит одно поле `Name` типа string.

Класс SpecialSymbolToken предназначен для специальных символов и содержит одно поле `Type` типа SpecialSymbolType.
В enum SpecialSymbolType описаны все специальные символы.

Класс ConstToken предназначен для различных констант и содержит одно generic поле `Value`, в котором хранится значения константы.

Класс TriviaToken предназначен для токенов, которые не попадаются под первые три типа, содержит одно поле `Type` типа enum TriviaTokenType.

## Тесты
Были проведены простые тесты на распознование лексем.
На данных входных данных тесты прошли успешно:
```pas

program HelloWorld(output);
var s:string;
    b:real;
begin
    b:=2 * 2 / 100 + 1 - 15;
    {comment section}
    b := 0.1234;
    s:= 's t';
    writeln('Hello, World!')
end.
```