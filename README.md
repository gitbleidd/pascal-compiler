# Лаб №1. IO модуль
Необходимо распарсить входные данные, разбить их на лексемы и вернуть токены. 
Допустима реализация с буфером и без.

## Описание задания
- Сделать начальную часть отчета, в которой будет проектирование IO модуля
- Запрогать спроектированные сущности (токен, вариант, сам IO с получением следующего токена)
- Проверить работоспособность потокового получения токенов

## Проектирование
Перед тем, как начать писать код я внимательно изучил книгу Л.А. Залоговой и выделил несколько сущностей:
- Модуль IO
- Лексический анализатор
- Токен

### Модуль IO
Задача модуля IO считывать данные из файла и передавать их. Также данный модуль должен иметь возможность принимать сообщения об ошибках из других модулей иметь интерфейс вывода.

В текущей реализации модуль IO может считывать строки из файла и возвращать их.
Обработки ошибок пока что нет.

### Лексический анализатор (сканер)
Задача лексического анализатора формировать токены (символы) исходной программы и строить их внутреннее представление. Также ЛА должен распознавать и исключать комментарии, которые не нужны для дальнейшей трансляции.

Сканер реализован в виде отдельного класса Lexer с полями: текущего символа, строки и соответственно их номеров.
Среди методов присутствует один единственный публичный метод GetNextToken() и вспомогательный метод Next().<br/>
Сканер умеет строить:
- ✅ операции (+, -, *, / и др. основные)
- ✅ константы (int, real, string)
- ✅ идентификаторы
- ✅ ключевые слова

### Токен
Так как сканер должен возвращать готовые лексемы, для был создан отдельный класс SyntaxToken. Данный класс содержит три поля: 
- Type типа TokenType
- Value типа object
- Position типа int

Поле Type принимает значения из Enum TokenType, в котором объявлены различные типы токенов, например PlusToken.<br/>
Поле Value принимает значение текущего токена, например, если это токен StringToken, то Value будет содержать значение строковой константы. Тип object был выбран не случайно, так это позволит хранить различные типы: int, float, string и при необходимости приводить их исходя из типа токена.
Несколько примеров для наглядности:
```cs
Type = VarToken
Value = "var name"

Type = ValueTokenFloat
Value = "1234.56"

Type = PlusToken
Value = null
```

## Тесты
Были проведены простые тесты на распознование лексем.
На данных входных данных тесты прошли успешно:
```pas

program HelloWorld(output);
var s:string;
    b:real;
begin
    b:=2 * 2 / 100 + 1 - 15;
    {comment section}
    b := 0.1234;
    s:= 's t';
    writeln('Hello, World!')
end.
```